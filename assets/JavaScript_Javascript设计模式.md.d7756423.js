import{_ as a,o as s,c as n,U as l}from"./chunks/framework.835c9fd2.js";const d=JSON.parse('{"title":"JavaScript 常见设计模式","description":"","frontmatter":{},"headers":[],"relativePath":"JavaScript/Javascript设计模式.md","filePath":"JavaScript/Javascript设计模式.md","lastUpdated":1632912264000}'),p={name:"JavaScript/Javascript设计模式.md"},o=l(`<h1 id="javascript-常见设计模式" tabindex="-1">JavaScript 常见设计模式 <a class="header-anchor" href="#javascript-常见设计模式" aria-label="Permalink to &quot;JavaScript 常见设计模式&quot;">​</a></h1><h3 id="惰性单例模式" tabindex="-1">惰性单例模式 <a class="header-anchor" href="#惰性单例模式" aria-label="Permalink to &quot;惰性单例模式&quot;">​</a></h3><p>惰性单例模式指的是需要的时候才创建对象实例。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Singleton</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">getInstance </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">instance</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">instance</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">instance</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Singleton</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">instance</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)()</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h3 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式&quot;">​</a></h3><p>策略模式是一种常用且有效的设计模式。</p><p>优点：</p><ul><li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。</li><li>策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展。</li><li>策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。</li><li>在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案。</li></ul><p>缺点：</p><ul><li>会在程序中增加许多策略类或者策略对象</li></ul><p>面向对象设计原则——单一职责原则： 指一个类（通常包括对象和函数等）而言，应该仅有一个引起它变化的原因。</p><h3 id="代理模式" tabindex="-1">代理模式 <a class="header-anchor" href="#代理模式" aria-label="Permalink to &quot;代理模式&quot;">​</a></h3><p>代理对象和本体是一致的，代理接手的请求的过程对用户来说是透明的，用户并不清楚代理和本体的区别</p><ul><li>用户可以放心地请求代理，他只关心是否能得到想要的结果；</li><li>在任何使用本体的地方都可以替换成代理；</li></ul><h3 id="迭代器模式" tabindex="-1">迭代器模式 <a class="header-anchor" href="#迭代器模式" aria-label="Permalink to &quot;迭代器模式&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">each</span></span></code></pre></div><h3 id="发布-订阅模式-观察者模式" tabindex="-1">发布-订阅模式（观察者模式） <a class="header-anchor" href="#发布-订阅模式-观察者模式" aria-label="Permalink to &quot;发布-订阅模式（观察者模式）&quot;">​</a></h3><p>定于对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖他的对象都将得到通知。</p><h3 id="命令模式" tabindex="-1">命令模式 <a class="header-anchor" href="#命令模式" aria-label="Permalink to &quot;命令模式&quot;">​</a></h3><ul><li><p>组合模式</p><p>组合模式要求组合对象和叶对象拥有相同的接口，且一对叶组合对象的操作必须具有一致性</p></li><li><p>双向映射关系 比如一个子节点可能会在多个父节点中出现，在这种复合情况下，就必须给父节点和子节点建立双向映射关系；</p></li><li><p>用职责链模式提高组合模式性能 比如一个复杂的树结构，节点很多，遍历整棵树性能表现不佳，那么可以在父子之间创建职责链；职责链模式的前提是需要开发者手动设置链条，这样可以实现子节点顺着链条找到对应的对象，反之，父节点也可以找到子节点；</p></li></ul><hr><p>参考文献:</p><p>[1]. JavaScripts设计模式与开发实践</p>`,23),e=[o];function t(c,r,i,y,F,D){return s(),n("div",null,e)}const u=a(p,[["render",t]]);export{d as __pageData,u as default};
